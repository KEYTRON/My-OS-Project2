; entry.S — точка входа, когда GRUB передаёт управление (Multiboot)
; Код написан для ассемблера NASM

BITS 32                     ; Изначально мы в 32‑битном режиме
ORG 0x0                     ; Базовый адрес (GRUB сам грузит ELF; для Multiboot нам не нужно прописывать конкретный origin)

; --------------------------------------------------------------------
; Multiboot header (чтобы GRUB понял, что это Multiboot‑совместимый образ)
; --------------------------------------------------------------------

align 4
multiboot_header:
    dd 0x1BADB002           ; magic number
    dd 0x00                 ; flags (не требуется гарантированный модуль)
    dd -(0x1BADB002)        ; checksum

; --------------------------------------------------------------------
; Начало кода
; --------------------------------------------------------------------
_start:
    cli                     ; Выключаем прерывания на всякий случай

    ; Загружаем глобальную таблицу дескрипторов (GDT) в 64‑битном формате
    ; Сперва установим GDT в 32‑битном режиме (базовый сегмент), потом позже
    ; в коде C мы полностью пересоздадим GDT для 64‑битного режима.

    ; Тут пропускаем настройку GDT/IDT в 32‑битном, тк мы собрались сразу в Long Mode
    ; Но для наглядности всё же настроим GDT с двумя дескрипторами

    lgdt [gdt_descriptor]   ; Загружаем GDT (32‑битный формат, потом переключимся)

    ; Переходим в 64‑битный режим:
    ; 1) Включаем PAE (Physical Address Extension) и Long Mode через CR4 и EFER
    ; 2) Включаем Protected Mode (bit 0 CR0)
    ; 3) Переходим по far jump в 64‑битный сегмент

    ; 1) Включаем PAE: CR4.PAE = 1
    mov eax, cr4
    or eax, 1 << 5           ; бит 5 = PAE (Physical Address Extension)
    mov cr4, eax

    ; 2) Включаем LME (Long Mode Enable) в MSR EFER (MSR index 0xC0000080)
    mov ecx, 0xC0000080
    rdmsr
    or eax, 1 << 8           ; EFER.LME = 1
    wrmsr

    ; 3) Включаем Protected Mode (CR0.PE = 1)
    mov eax, cr0
    or eax, 1
    mov cr0, eax

    ; Короче: теперь мы можем прыгнуть в 64‑битный код
    jmp 0x08:long_mode_entry ; far jump: сегмент 0x08 – наш 64‑битный кодовый сегмент

[BITS 64]
long_mode_entry:
    ; Устанавливаем сегменты для 64‑битного режима
    mov ax, 0x10             ; сегмент данных (0x10) 
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

    ; Теперь у нас 64‑битный режим, можно вызвать kernel_main
    extern kernel_main       ; объявляем, что kernel_main реализован в C
    call kernel_main

halt:
    hlt
    jmp halt

; --------------------------------------------------------------------
; Описание GDT (32‑битный вариант, который нужно заменить позже)
; --------------------------------------------------------------------
gdt_start:
    dq 0x0000000000000000    ; NULL‑сегмент
    dq 0x00cf9a000000ffff    ; Кодовый сегмент 32‑бит, базовый 0, размер 4GB
    dq 0x00cf92000000ffff    ; Данные сегмент 32‑бит, базовый 0, размер 4GB
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1   ; размер таблицы (limit)
    dq gdt_start                 ; базовый адрес таблицы

; Конец entry.S